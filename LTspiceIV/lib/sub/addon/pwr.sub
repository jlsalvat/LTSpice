********************************************************************************
*
* These are the subcircuit files for the symbols in [Pwr]. They are intended to
* be idealized models of the likes found in PSIM, Matlab, OrCAD, etc, for aid in
* large scale simulation of schematics, without the penalty of speed and without
* sacrificing accuracy.
*
*								Vlad
* 
********************************************************************************
*
* [CONTENTS]
*
* - The list of symbols in [Pwr], in alphabetical order:
*
* 3lvl_mod	- three-phase, three-level modulation controller
* 3ph_ACMotor	- three-phase induction motor
* 3ph_br_cm	- three-phase switching bridge, current mode
* 3ph_br_vm	- three-phase switching bridge, voltage mode
* 3ph_gen	- three-phase harmonic generator
* 3ph_SW	- three-phase to three-phase timed switch
* BrdgRect	- three-phase diode bridge rectifier
* BrdgRectThy	- three-phase thyristor bridge rectifier
* Cable		- power cable
* Disturb	- disturbance signal inducer
* HystComp	- single-phase hysteresis modulation controller
* Isense	- isolated current sensor
* RLC		- three-phase, series/parallel, RLC load
* SVHCC		- three-phase, space-vector, hysteresis current controller
* SVPWM		- three-phase, space-vector, pulse width modulation controller
* TL494		- behavioural model
* Transforms	- Clarke/Park/symmetrical components (separate .sub file)
* Vsense	- isolated voltage sensor
* sym		- symmetrical components matrix, phasor approach (separate .sub)
* WattMeter	- watt-meter
* wt		- angle generator
*
********************************************************************************
*
*	3ph_mod, HystComp, SVHCC, SVPWM - Single-/three-phase modulators
*
********************************************************************************
*
* [SYMBOL]
*
* - All inputs and control inputs are internally grounded with 1GOhm.
*
* - '_EN' is active low, therefore leaving it floating means enabled.
*
*
* [CHARACTERISTICS]
*
* - For all, inputs are floating and outputs are 1 Ohm.
*
****************************************
*
*	Hysteresis, single-phase
*
****************************************
*
* [SYMBOL]
*
* IN		= signal input;
* CMP		= feedback signal;
* Q,_Q		= complementary outputs;
* _EN		= _enable/disable pin, internally grounded with 1GOhm.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* err	[V]	= error band;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
*
*
* [NOTES]
*
* - Since for a three-phase application three similar subcircuits would have
* been needed, using the same block for a single-phase would have meant an
* unnecessary slow-down. Therefore, for a three-phase three of these are needed
* and only one for single-phase.
*
********************************
*
*		 reference
*		 |   feedback
*		 |   |	output
*		 |   |	|  complementary output
*		 |   |	|  | external error
*		 |   |	|  | |	 _enable/disable
*		 |   |	|  | |	 |
.subckt HystComp in cmp Q _Q er _EN
.param dt=1u err=0 Vhigh=1.1 Vlow=0 td=25n
Be1 1 cmp V=if(err==0,v(er),err)
AS in 1 0 0 0 0 a 0 SCHMITT ref=0 td={td} vhigh={vhigh} vlow={vlow}
Be2 cmp 2 V=if(err==0,v(er),err)
AR 2 in 0 0 0 0 b 0 SCHMITT ref=0 td={td} vhigh={vhigh} vlow={vlow}
ASR a b 0 0 0 4 3 0 SRFLOP vhigh={vhigh} vlow={vlow} td={td}
AdQ 0 3 0 0 0 0 6 0 AND td={dt+td} vhigh={vhigh} vlow={vlow}
AQ 0 3 5 6 0 0 Q 0 AND td={td} vhigh={vhigh} vlow={vlow}
Ad_Q 0 4 0 0 0 0 7 0 AND td={dt+td} vhigh={vhigh} vlow={vlow}
A_Q 0 4 5 7 0 0 _Q 0 AND td={td} vhigh={vhigh} vlow={vlow}
A_en _EN 0 0 0 0 5 0 0 BUF td={td} vhigh={vhigh} vlow={vlow}
.ends HystComp
****************************************
*
*	Three-level modulation
*
****************************************
*
* [SYMBOL]
*
* in[a,b,c]	= three-phase signal input;
* TRI		= external carrier;
* _EN		= _enable/disable;
* A,B,C		= true control outputs;
* _A,_B,_C	= complementary control outputs.
*
* - 'TRI' has no effect unless f>0.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* f	[Hz]	= carrier frequency, symmetrical, set 0 for external;
* Vpk	[V]	= peak voltage level for the carrier;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
* vh	[V]	= LTspice's specific hysteresis voltage for the comparators,
*		useful for noisy inputs, default <0>;
*
********************************
*
*		 'A' phase input
*		  |  'B' phase input
*		  |   |	 'C' phase input
*		  |   |	  |   external modulation
*		  |   |	  |   |	 phase 'A' output
*		  |   |	  |   |  |   phase 'A' complementary output
*		  |   |	  |   |  |   |	phase 'B' output
*		  |   |	  |   |	 |   |	|   phase 'B' complementary output
*		  |   |	  |   |	 |   |	|   |  phase 'C' output
*		  |   |	  |   |	 |   |	|   |  |   phase 'C' complementary output
*		  |   |	  |   |	 |   |	|   |  |   |  _enable/disable
*		  |   |	  |   |	 |   |	|   |  |   |   |
.subckt 3lvl_mod INa INb INc TRI A  _A  B  _B  C  _C  _EN
.param vhigh=1 vlow=0 Vpk=1 f=10k dt=0.1u
.param td=25n vh=0
Aa 0 3 0 EN 0 0 A 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.6
A_a 0 4 0 EN 0 0 _A 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.4
Ab 0 5 0 EN 0 0 B 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.6
A_b 0 EN 0 6 0 0 _B 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.4
Ac 0 7 0 EN 0 0 C 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.6
A_c 0 EN 0 8 0 0 _C 0 AND vhigh=vhigh vlow=vlow td={td} ref=0.4
Aia ina 1 0 0 0 4 3 0 SCHMITT td={td} vt=0 vh={vh} trise={5*dt}
Aib inb 1 0 0 0 6 5 0 SCHMITT td={td} vt=0 vh={vh} trise={5*dt}
Aic inc 1 0 0 0 8 7 0 SCHMITT td={td} vt=0 vh={vh} trise={5*dt}
Aen _EN 0 0 0 0 EN 0.1 0 SCHMITT td={td} vt={(Vhigh+Vlow)/2} vh=0
Rina ina 0 1G
Rinb inb 0 1G
Rinc inc 0 1G
Ren _EN 0 1G
Aosc {2*u(f)} {0.1*u(f)} 0 0 0 {2*u(f)} {u(f)} 0 SCHMITT vt=0 vh={Vpk} vhigh={2*Vpk} vlow={-2*Vpk} td={td} trise={1/f**u(f)}
Rosc tri 1 1Meg
.ends 3lvl_mod
********************************************************
*
*	Space-vector hysteresis current controller
*
********************************************************
*
* [GENERAL]
*
* - Simple strategy for minimizing the switchings and the number of logic gates.
*
*	O1 O2 O3 | I1 I2 I3 | S1 S2 S3
*	-------------------------------
*	1  0  0  | 1  0  0  | 1  0  0
*	         | 1  1  0  | 1  1  0
*	         | x  x  x  | 0  0  0
*	-------------------------------
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* hi,ho	[V]	= inner and outer bands levels;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
* vh	[V]	= LTspice's specific hysteresis voltage for Schmitt triggers,
*		sometimes useful for noisy inputs, default <0>;
*
********************************
*
*	      'A' phase reference
*	       |  'B' phase reference
*	       |   |  'C' phase reference
*	       |   |   |  'A' phase compare
*	       |   |   |   | 'B' phase compare
*	       |   |   |   |  |	'C' phase compare
*	       |   |   |   |  |	 | phase 'A' output
*	       |   |   |   |  |	 | |   phase 'A' complementary output
*	       |   |   |   |  |	 | |   |  phase 'B' output
*	       |   |   |   |  |	 | |   |  |   phase 'B' complementary output
*	       |   |   |   |  |	 | |   |  |   |  phase 'C' output
*	       |   |   |   |  |	 | |   |  |   |  |   phase 'C' complementary output
*	       |   |   |   |  |	 | |   |  |   |  |   |  _enable/disable
*	       |   |   |   |  |	 | |   |  |   |  |   |	 |
.subckt SVHCC ia* ib* ic* ia ib ic Sa _Sa Sb _Sb Sc _Sc _EN
.param hi=100m ho=200m vhigh=1 vlow=0 dt=1u td=25n
Aao 0 4 0 EN 0 0 Sa 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Aa2 ia* ia 0 0 0 _o1 o1 0 SCHMITT td={td} vt=0 vh={ho}
Aa1 ia* ia 0 0 0 _i1 i1 0 SCHMITT td={td} vt=0 vh={hi}
Ab2 ib* ib 0 0 0 _o2 o2 0 SCHMITT td={td} vt=0 vh={ho}
Ab1 ib* ib 0 0 0 _i2 i2 0 SCHMITT td={td} vt=0 vh={hi}
Ac2 ic* ic 0 0 0 _o3 o3 0 SCHMITT td={td} vt=0 vh={ho}
Ac1 ic* ic 0 0 0 _i3 i3 0 SCHMITT td={td} vt=0 vh={hi}
Aa111 0 1 2 3 0 5 4 0 OR td={td/2} trise={5*dt} tfall={td/2}
Ab111 0 11 12 13 0 15 14 0 OR td={td/2} trise={5*dt} tfall={td/2}
Ac111 0 21 22 23 0 25 24 0 OR td={td/2} trise={5*dt} tfall={td/2}
Aa_o 0 EN 0 5 0 0 _Sa 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Abo 0 14 0 EN 0 0 Sb 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Ab_o 0 EN 0 15 0 0 _Sb 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Aco 0 24 0 EN 0 0 Sc 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Ac_o 0 EN 0 25 0 0 _Sc 0 AND td={td} vhigh={vhigh} vlow={vlow} ref=0.1
Aa11 _o2 o3 i1 _i2 i3 0 1 0 AND td={td}
Aa12 o1 _o2 i1 _i2 _i3 0 2 0 AND td={td}
Aa13 o1 _o3 i1 i2 _i3 0 3 0 AND td={td}
Ab11 o2 _o3 _i1 i2 _i3 0 11 0 AND td={td}
Ab12 _o1 o2 _i1 i2 i3 0 12 0 AND td={td}
Ab13 o1 _o3 i1 i2 _i3 0 13 0 AND td={td}
Ac11 _o1 o3 _i1 _i2 i3 0 21 0 AND td={td}
Ac12 _o2 o3 i1 _i2 i3 0 22 0 AND td={td}
Ac13 _o1 o2 _i1 i2 i3 0 23 0 AND td={td}
A_en _EN 0 0 0 0 EN 0 0 SCHMITT td={td} vt={(vhigh+vlow)/2} vh=0
Ren _EN 0 1G
Ria ia 0 1G
Ria* ia* 0 1G
Rib ib 0 1G
Rib* ib* 0 1G
Ric ic 0 1G
Ric* ic* 0 1G
.ends SVHCC
********************************************************
*
*	Space-vector pulse-width modulation
*
********************************************************
*
* [GENERAL]
*
* - This is the symmetrical case, for the lowest switching harmonic content, but
* also for a simple approach in modelling.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* f	[Hz]	= switching frequency;
* a,b=<-1,1>	= sign control of the inputs for internal angle generation;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
*
*
* [NOTES]
*
* - The inputs are in quadrature, of the form sin/-cos and their amplitudes
* dictate the M, modulation factor, therefore keep <1.
*
* - The angle utilizes atan2(-v(b),-v(a)) by default, but this can be changed
* via {a} and {b}.
*
********************************
*
*	      input
*	      | quadrature input
*	      |	| phase 'A' output
*	      |	| |   phase 'A' complementary output
*	      |	| |   |  phase 'B' output
*	      |	| |   |  |   phase 'B' complementary output
*	      |	| |   |  |   |  phase 'C' output
*	      |	| |   |  |   |	|   phase 'C' complementary output
*	      |	| |   |  |   |	|   |  _enable/disable
*	      |	| |   |  |   |	|   |	|
.subckt SVPWM A B Sa _Sa Sb _Sb Sc _Sc _EN
.param f=5k dt=1u a=-1 b=-1 vhigh=1 vlow=0 td=10n
B_atan2 0 wt i=atan2(sgn(b)*v(b),sgn(a)*v(a))+pi Rpar=1
B_M 0 M i=hypot(v(b),v(a)) Rpar=1
B_alpha 0 alpha i=v(wt)-floor(v(wt)*3/pi)*pi/3 Rpar=1
B_sector 0 sector i=limit(0,6,ceil(v(wt)*3/pi)) Rpar=1
B_t1 0 t1 i=sin(v(alpha)+2*pi/3)*v(M) Rpar=1
B_t2 0 t2 i=sin(v(alpha))*v(M) Rpar=1
B_t3 0 t0 i=(1-v(t1)-v(t2))/2 Rpar=1
B_t4 0 t0_1 i=v(t0)+v(t1) Rpar=1
B_t5 0 t0_2 i=v(t0)+v(t2) Rpar=1
B_t6 0 t0_1_2 i=v(t0)+v(t1)+v(t2) Rpar=1
B_Ta 0 s1 i=table( v(sector), 0, 0, 1, v(t0), 2, v(t0_2), 3, v(t0_1_2), + 4,
+ v(t0_1_2), 5, v(t0_1), 6, v(t0), 7, 0 ) Rpar=1
Aic fsw s3 0 0 0 24 21 0 SCHMITT ref=0 td={td} vhigh={vhigh} vlow={vlow}
Ada 0 1 0 0 0 3 2 0 AND td={td+dt} vhigh={vhigh} vlow={vlow}
Aa 0 1 EN 2 0 0 Sa 0 AND td={td} vhigh={vhigh} vlow={vlow}
A_a 0 3 EN 4 0 0 _Sa 0 AND td={td} vhigh={vhigh} vlow={vlow}
B_Tb 0 s2 i=table( v(sector), 0, 0, 1, v(t0_1), 2, v(t0), 3, v(t0), +4,
+ v(t0_2), 5, v(t0_1_2), 6, v(t0_1_2), 7, 0 ) Rpar=1
Aib fsw s2 0 0 0 14 11 0 SCHMITT ref=0 td={td} vhigh={vhigh} vlow={vlow}
Adb 0 11 0 0 0 13 12 0 AND td={td+dt} vhigh={vhigh} vlow={vlow}
Ab 0 11 EN 12 0 0 Sb 0 AND td={td} vhigh={vhigh} vlow={vlow}
A_b 0 13 EN 14 0 0 _Sb 0 AND td={td} vhigh={vhigh} vlow={vlow}
B_Tc 0 s3 i=table( v(sector), 0, 0, 1, v(t0_1_2), 2, v(t0_1_2), 3, v(t0_1), + 4,
+ v(t0), 5, v(t0), 6, v(t0_2), 7, 0 ) Rpar=1
Aia fsw s1 0 0 0 4 1 0 SCHMITT ref=0 td={td} vhigh={vhigh} vlow={vlow}
Adc 0 21 0 0 0 23 22 0 AND td={td+dt} vhigh={vhigh} vlow={vlow}
Ac 0 21 EN 22 0 0 Sc 0 AND td={td} vhigh={vhigh} vlow={vlow}
A_c 0 23 EN 24 0 0 _Sc 0 AND td={td} vhigh={vhigh} vlow={vlow}
Cosc fsw 0 {.5/f} Rpar=1G ic=0
Gosc 0 fsw EN 100 1
A_en _EN 0 0 0 0 EN 0 0 SCHMITT td={td} vt={(vhigh+vlow)/2}
Aosc fsw 0 0 0 0 0 100 0 SCHMITT td={td} vt=0.5 vh=0.5 vhigh={vhigh*2} vlow={vlow}
.ends SVPWM
********************************************************************************
*
*			3ph_ACMotor - Induction motor
*
********************************************************************************
*
* [GENERAL]
*
* - It uses the general DQ reference frame and some approximation formulas, such
* as air-gap losses negligeable and iron losses being 3.5% of the total. Using
* the second method may yield some strange results.
*
*
* [SYMBOL]
*
* - It uses the non-isolated T-model for the transformer so the parameters are
* specified using either the direct mode (resistances and inductances), or the
* indirect mode (power, frequency, torque, etc).
*
*
* [PARAMETERS]
*
*
* - Direct mode:
*
* Lm	[H]	= magnetizing inductance;
* Lr	[H]	= rotor's leakage inductance;
* Ls	[H]	= stator's leakage inductance;
* Rf	[Ohm]	= iron losses equivalent resistance;
* Rr	[Ohm]	= rotor's resistance;
* Rs	[Ohm]	= stator's resistance.
*
* - Indirect mode (set all the above to zero):
*
* Pn	[W]	= shaft's delivered power;
* fn	[Hz]	= working frequency;
* Vn	[V]	= nominal line-to-line voltage;
* In	[A]	= nominal current, if zero then automatically calculated;
* phi	[rad]	= displacement factor;
* slip		= slip factor;
* Zp		= number of poles (2 pairs => Zp=4);
* J	[Kg*m^2]= moment of inertia, if zero, additional capacitor is needed at
*		pin 'W';
* DY=<0,1>	= delta <0> or wye <1> configuration.
*
* - Hidden:
*
* tripdv,tripdt	= LTspice's specific for behavioural sources, default 10V/1us;
* att		= attenuation, a minor tweak to ease up the calculations, should
*		not be needed.
*
*
* [CHARACTERISTICS]
*
* - .uic may be needed for the simulation command.
*
* - The back-EMF is modelled using F sources shunted by 1GOhm resistors(!).
*
********************************
*
*		   'A' phase input
*		    |'B' phase input
*		    | |'C' phase input
*		    | |	| rotation
*		    | |	| | inertia
*		    | |	| | |
.subckt 3ph_ACMotor a b c W J
.param Lm=0  Lr=0  Ls=0 Rf=0  Rr=0  Rs=0
.param Pn=100k  fn=50  Vn=400  In=0  phi=0.85  Zp=4  slip=40m
+ DY=1  J=5  att=1
+  prc=0.035  prcRr=0.4 prcRs=0.9  prcLs=0.3  prcLr=0.85
.param Lm_=if(Lm==0,_Lm,Lm) Ls_=if(Ls==0,_Ls,Ls) Lr_=if(Lr==0,_Lr,Lr)
.param Rf_=if(Rf==0,_Rf,Rf) Rs_=if(Rs==0,_Rs,Rs) Rr_=if(Rr==0,_Rr,Rr)
.param _In=if(In==0,Pn/sqrt(3)/Vn/phi*_DY,In)
+ _DY=if(DY==1,sqrt(3),1)
+ Zeq=Vn/_In  Req=Zeq*phi  sigma=(1-phi)/(1+phi) Re=Pn*slip/3/(1*slip)/_In**2
+ _Lm=Zeq/2/pi/fn/sqrt(sigma)  _Ls=0.3*sigma*_Lm  _Lr=_Ls*(1-slip)
+ _Rs=Re*slip*2  _Rr=_Rs*(1-slip)  _Rf=Vn/_In/prc
Cj w 0 Q=x*J
Bw 0 j I=( I(Ldm)*I(Lqr) - I(Lqm)*I(Ldr) ) tripdv={tripdv} tripdt={tripdt} Rpar={3/2*Zp*Lm_}
Ldm D 0 {Lm_} ic=0 Cpar=0 Rpar={Rf_} Rser=0
Ldr D Dr {Lr_} ic=0 Rser=0 Rpar=0 Cpar=0
Lds Ds D {Ls_} ic=0 Rser=0 Rpar=0 Cpar=0
Lqr Q Qr {Lr_} ic=0 Rser=0 Rpar=0 Cpar=0
Lqs Qs Q {Ls_} ic=0 Rser=0 Rpar=0 Cpar=0
Fa a N Lds {1/att}
Bs 0 N002 i=-v(w)*(Lr_*I(Ldr)-Lm_*I(Ldm)) tripdv={tripdv} tripdt={tripdt} Rpar=1
Bd 0 N001 i=v(w)*(Lr_*I(Lqr)-Lm_*I(Lqm)) tripdv={tripdv} tripdt={tripdt} Rpar=1
Ga 0 Ds a 0 {att*2/3/Rs_}
Rds Ds 0 {Rs_}
Gb 0 Ds 0 b {att/3/Rs_}
Gc 0 Ds 0 c {att/3/Rs_}
Gq 0 Qs b c {att/sqrt(3)/Rs_}
Rqs Qs 0 {Rs_}
Fbd b N Lds {-1/2/att}
Fbq b N Lqs {sqrt(3)/2/att}
Fcd c N Lds {-1/2/att}
Fcq c N Lqs {-sqrt(3)/2/att}
Ra a N 1Meg
Rb b N 1Meg
Rc c N 1Meg
R1 Qr 0 {Rr_}
G1 0 Qr N002 0 {sqrt(3/2)*Zp/Rr_}
R2 Dr 0 {Rr_}
G2 0 Dr N001 0 {sqrt(3/2)*Zp/Rr_}
Lqm Q 0 {Lm_} ic=0 Cpar=0 Rpar={Rf_} Rser=0
G3 0 w j 0 {1/att**2}
R3 w 0 1G
.ends 3ph_ACMotor
********************************************************************************
*
*		3ph_br_cm, 3ph_br_vm - Three-phase switching bridges
*
********************************************************************************
*
* [SYMBOL]
*
* INa,INb,INc	= control inputs, internally grounded with 1GOhm;
* _INa,_INb,_INc= complementary control inputs, internally grounded with 1GOhm;
* DC+,DC-	= DC voltage/current supply;
* A,B,C		= three-phase output.
*
*
* [PARAMETERS]
*
* Ron,Roff[Ohm]	= on-/off-state resistance;
* Vfwd	[V]	= forward voltage drop;
* Vdrev	[V]	= reverse breakdown voltage;
* Rs,Cs	[Ohm,F]	= series snubber across each device.
*
* - Hidden:
*
* vt,vh	[V]	= LTspice's SW specific threshold and hysteresis voltage.
*
*
* [CHARACTERISTICS]
*
* - Logic levels for control default to <0,1> with vt=0.5V and vh=0V. Increase
* {vh} if noise is a problem.
*
*
* [NOTES]
*
* - There's no dead-time so it should be supplied externally.
*
********************************
*
*	Voltage-mode
*
********************************
*
*		    phase 'A' control
*		    |	 phase 'A' complementary control
*		    |	 |    phase 'B' control
*		    |	 |    |	   phase 'B' complementary control
*		    |	 |    |	   |	phase 'C' control
*		    |	 |    |	   |	|    phase 'C' complementary control
*		    |	 |    |	   |	|    |	phase 'A' output
*		    |	 |    |	   |	|    |	| phase 'B' output
*		    |	 |    |	   |	|    |	| | phase 'C' output
*		    |	 |    |	   |	|    |	| | | Positive supply
*		    |	 |    |	   |	|    |	| | | |   Negative supply
*		    |	 |    |	   |	|    |	| | | |   |
.subckt 3ph_br_vm  INa _INa  INb _INb  INc _INc A B C DC+ DC-
.param Ron=50m Roff=100k Vfwd=1 Vrev=1k Rs=1k Cs=100p vt=0.5 vh=0
.model sw sw Ron={Ron*2} Roff={Roff*2} vt={vt} vh={-vh}
.model dd d vfwd={Vfwd} Ron={Ron*2} Roff={Roff*2} Vrev={Vrev}
Sa A DC+ INa 0 SW
Da A DC+ Dd
Ca DC+ A {Cs} Rser={Rs}
S_a DC- A _INa 0 SW
C_a A DC- {Cs} Rser={Rs}
Sb B DC+ INb 0 SW
Cb DC+ B {Cs} Rser={Rs}
S_b DC- B _INb 0 SW
C_b B DC- {Cs} Rser={Rs}
Sc C DC+ INc 0 SW
Cc DC+ C {Cs} Rser={Rs}
S_c DC- C _INc 0 SW
C_c C DC- {Cs} Rser={Rs}
D_a DC- A Dd
Db B DC+ Dd
D_b DC- B Dd
Dc C DC+ Dd
D_c DC- C Dd
Ra INa 0 1G
Rb INb 0 1G
Rc INc 0 1G
R_a _INa 0 1G
R_b _INb 0 1G
R_c _INc 0 1G
.ends 3ph_br_vm
********************************
*
*	Current-mode
*
********************************
*
*		    phase 'A' control
*		    |	 phase 'A' complementary control
*		    |	 |    phase 'B' control
*		    |	 |    |	   phase 'B' complementary control
*		    |	 |    |	   |	phase 'C' control
*		    |	 |    |	   |	|    phase 'C' complementary control
*		    |	 |    |	   |	|    |	phase 'A' output
*		    |	 |    |	   |	|    |	| phase 'B' output
*		    |	 |    |	   |	|    |	| | phase 'C' output
*		    |	 |    |	   |	|    |	| | | Positive supply
*		    |	 |    |	   |	|    |	| | | |   Negative supply
*		    |	 |    |	   |	|    |	| | | |   |
.subckt 3ph_br_cm  INa _INa  INb _INb  INc _INc A B C DC+ DC-
.param Ron=50m Roff=100k Vfwd=1 Vrev=1k Rs=1k Cs=100p vt=0.5 vh=0
.model sw sw Ron={Ron*2} Roff={Roff*2} vt={vt} vh={-vh}
.model dd d vfwd={Vfwd} Ron={Ron*2} Roff={Roff*2} Vrev={Vrev}
Sa A DC+ INa 0 SW
Da A DC+ Dd
Ca DC+ A {Cs} Rser={Rs}
S_a DC- A _INa 0 SW
C_a A DC- {Cs} Rser={Rs}
Sb B DC+ INb 0 SW
Cb DC+ B {Cs} Rser={Rs}
S_b DC- B _INb 0 SW
C_b B DC- {Cs} Rser={Rs}
Sc C DC+ INc 0 SW
Cc DC+ C {Cs} Rser={Rs}
S_c DC- C _INc 0 SW
C_c C DC- {Cs} Rser={Rs}
D_a DC- A Dd
Db B DC+ Dd
D_b DC- B Dd
Dc C DC+ Dd
D_c DC- C Dd
Ra INa 0 1G
Rb INb 0 1G
Rc INc 0 1G
R_a _INa 0 1G
R_b _INb 0 1G
R_c _INc 0 1G
.ends 3ph_br_cm
********************************************************************************
*
*		3ph_gen - Three-phase harmonic generator
*
********************************************************************************
*
* [GENERAL]
*
* - Symmetrical/asymmetrical, odd/even harmonics generator, true until 51st, can
* be voltage or current. It has a Gaussian bell-like spectrum shaping, per
* harmonic divizor exponent, custom signum function for great flexibility in
* assigning  +/- signs to each harmonic, separate and general amplitude/offset/
* phase setting, optional noise and up to three harmonics to be added/subracted
* separate from the rest.
*
*
*
* [SYMBOL]
*
* 1,2,3		= outputs of the three phases.
* NUL		= the common for the Y-shaped generators;
* AM,FM,PM	= external control of amplitude, frequency ahd phase, internally
*		grounded with 1GOhm resistors.
*
* - 'NUL' can be grounded or floating, but for the latter there may be cases
* where a high-valued resistance or capacitor may be needed.
*
* - Unlike the amplitude and frequency, where the corresponding
* parameters, {amp} and {f}, need to be zero, the external phase is added to
* {phi}'s value.
*
*
* [PARAMETERS]
*
* sym=<0,1>	= whether phases '2' and '3' should be identical to '1' or only
*		the fundamentals displaced;
* f	[Hz]	= fundamental frequency;
* amp	[V]	= general ampltiude;
* phi	[rad]	= harmonics' phase displacement (not fundamental);
* Ro	[Ohm]	= output resistance, default <1>;
* N=+/-<0:51>	= sets the highest number of harmonics;
* DC[1:3] [V]	= per-phase offset;
* A[1:3]  [V]	= per-phase p.u. amplitude;
* phi[1:3][rad]	= fundametal's per-phase displacement;
* h[1:3]	= up to three user selected harmonics to be added/subtracted if
*		present or not;
* noise=<0:inf>	= level of white noise, <0:1> should be enough though;
* sigma=<0+:inf>= Gaussian bell's width for spectrum-shaping;
* a,b,c,d,e	= terms for the custom signum functions;
* xp=<0:inf>	= per-harmonic divizor's exponent, e.g. sin(7x)/7^xp;
*
* - Hidden:
*
* tripdv,tripdt	= LTspice's characteristic for B-sources, default 100V/1us.
*
*
* [CHARACTERISTICS]
*
* - {N} has three possible values:
*	- positive, odd 	=> odd harmonics, only;
*	- positive, even	=> even harmonics, only;
*	- negative		=> odd+even harmonics.
*
* - External control for frequency and amplitude are available at pins 'FM' and
* 'AM' provided the corresponding parameters are set to zero: f=0, amp=0. The
* general displacement, though, is given by V(PM)+phase, where "phase" is either
* {phi} or {phi[1:3]};
*
* - {h[1:3]}, when set, will:
*	- subtract number <h[x]'s value> harmonic if present;
*	- add number  <h[x]'s value> harmonic if not present.
*  This will be done obeying the spectrum's shape given by {sigma} and divisor's
* exponent, {xp}.
*  E.g.: amp=1, N=0, sigma=20, xp=1 and h1=100 => ~0.1uVpp
*
* - There are two methods of assigning signs to harmonics:
*	1. by using only {a} and {b} with negative values in this formula:
* (-1)**round( (a*x+1)/b ); this needs to be calculated beforehand in order to
* know how the signs occur, but it may yield results impossible to achieve with
* the second version, or
*	2. by using all the five letters for a function involving mod(), but
* which works in an intuitive manner:
*	a - represents the number of positive values
*	b -	-- ,, --	     zero values
*	c -	-- ,, --	     negative values
*	d -	-- ,, --	     zero values
*	e -	-- ,, --	     delayed values
*  The first four parameters set the period of the repeating sequence of sgn()
* functions and {e} sets the delay.
*  Example: a=2, b=3, c=4, d=5 and e=-3
* => the sequence's period is T = a+b+c+d = 14, meaning the occurences of the
* signs will repeat every 14 harmonics, like this:
*
*    n	|1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21	...
*  -----+---------------------------------------------------------------
*    a	|	. +  +					   |+  + 
*    b	|	.	0  0  0				   |	  0  0 ...
*    c	|	.		 -  -  -  -		   |
*    d	|0  0  0.			     0  0  0  0  0 |
*	|<- e ->|
*
*  The sign of {e} is interpreted in the trigonometric way.
*
* - The two methods don't keep count of {N}, e.g. if N=13 there will only be odd
* harmonics up until the 13th, but {n} (from the table above) increments by 1,
* not 2, so if, example still, alternating +/- signs are needed, +1, -3, +5, -7,
* ..., then the correct values are: a=2, b=0, c=2, d=0 (e=+/-<0,2,4...>).
*
* - Ro=0 means the block will act as a current generator instead of a voltage
* one, with the {arrows} pointing towards the outputs; for sinking current set
* {amp} negative.
*
* - {sigma} applies a Gaussian bell-like spectrum shape to the harmonics using
* the general exp(-1/2*((n-1)/sigma)^2) formula (n-1 because the fundamental is
* always unity).
*
*
*
* [NOTES]
*
* - Here are a few settings to achieve some known waveforms:

*
*			|   N	|   a	|   b	|   c	|   d	|   e	|  xp
* ----------------------+-------+-------+-------+-------+-------+-------+-------
* square wave		| -2n-1	|   1	|   0   |   0	|   0	|   x	|   1
* trapezoidal wave	| -2n-1	|   2	|   1   |   2	|   1	|   0	|   2
* UPS square-sine	| -2n-1	|   4	|   0	|   4	|   0	|  -2	|   1
* 1ph rectified RC load*| -2n-1	|   2	|   0	|   2	|   0	|   0	|   0
* 3ph rectified RC load*| -2n-1	|   2	|   2	|   2	|   0	|   0	|   0
* symmetric triangular	| -2n-1	|   2	|   0	|   2	|   0	|   0	|   2
* asymmetric triangular	|   2n	|   1	|   0	|   1	|   0	|   0	|   1
*	* set {sigma} lower, ~10~15.
*
* - In general, for N>0, (e.g.) [a,b,c,d]=[4,0,4,0]  <=>  [a,b,c,d]=[3,1,3,1].
*
************************************************
*
*		output phase 'A'
*		| output phase 'B'
*		| | output phase 'C'
*		| | |  Y-connected null
*		| | |  |  external frequency control
*		| | |  |  |  external amplitude control
*		| | |  |  |  |	external phase control
*		| | |  |  |  |	|
.subckt 3ph_gen 1 2 3 NUL FM AM PM
.param  sym=1 f=50 amp=325 phi=0 Ro=1 N=-51
.param  dc1=0 dc2=0 dc3=0 A1=1 A2=1 A3=1
.param  h1=0 h2=0 h3=0 phi1=0 phi2=0 phi3=0
.param  noise=0 sigma=25 a=2 b=1 c=2 d=1 e=0 xp=1
.param tripdv=100 tripdt=1u
.func spec(x)=exp( -0.5*((x-1)/sigma)**2 )
.func s(x,y)=sin(x*2*pi*idt(v(freq))+y)
.func h(x,y)=if( x==0 | x>abs(N), 0, spec(x)*s(x,(v(PM)+y)*x**sym)/x**xp*ch(x) )
.func hx(x,y)=sgn(N+.5-x)*if(x==0|(x==1&par(N)&N>=0),0,spec(x)*s(x,(v(PM)+y)*x**sym)/x**xp*ch(x))
.func mod(x,y)=x-floor(x/y)*y
.func ch1(x)=u(mod(x-1-a-e,a+b+c+d)-b-c-d+1)-u(mod(x-1+d-e,a+b+c+d)-a-b-d+1)
.func ch2(x)=(-1)**round((-a*(x-1)/2+1)/-b)
.func ch(x)=if( a<0 & b<0, ch2(x), ch1(x) )
.func noiz(x)=x*white(104*pi*idt(v(freq)))
.func par(x)=1-ceil(x/2)+floor(x/2)
.param  off=2*pi/3
.func zi(y)=if(par(N)&N>0,0,h(3,y)+h(5,y)+h(7,y)+h(9,y)+h(11,y)+h(13,y)+h(15,y)+
+ h(17,y)+h(19,y)+h(21,y)+h(23,y)+h(25,y)+h(27,y)+h(29,y)+h(31,y)+h(33,y)+h(35,y)+
+ h(37,y)+h(39,y)+h(41,y)+h(43,y)+h(45,y)+h(47,y)+h(49,y)+h(51,y) )
.func zp(y)=if(par(N+1)&N>0, 0, h(2,y)+h(4,y)+h(6,y)+h(8,y)+h(10,y)+h(12,y)+h(14,y)+h(16,y)+
+ h(18,y)+h(20,y)+h(22,y)+h(24,y)+h(26,y)+h(28,y)+h(30,y)+h(32,y)+h(34,y)+h(36,y)+
+ h(38,y)+h(40,y)+h(42,y)+h(44,y)+h(46,y)+h(48,y)+h(50,y) )
.func z(y)=zp(y)+zi(y)
Ba 0 _a i=hx(1,phi1)+z(phi)+noiz(noise)-hx(h1,if(h1==1,phi1,phi))-hx(h2,if(h2==1,phi1,phi))-hx(h3,if(h3==1,phi1,phi)) tripdv={tripdv} tripdt={tripdt}
Bb 0 _b i=hx(1,phi2-off)+z(phi-off)+noiz(noise)-hx(h1,-off+if(h1==1,phi2,phi))-hx(h2,-off+if(h2==1,phi2,phi))-hx(h3,-off+if(h3==1,phi2,phi)) tripdv={tripdv} tripdt={tripdt}
Bc 0 _c i=hx(1,phi3+off)+z(phi+off)+noiz(noise)-hx(h1,off+if(h1==1,phi3,phi))-hx(h2,off+if(h2==1,phi3,phi))-hx(h3,off+if(h3==1,phi3,phi)) tripdv={tripdv} tripdt={tripdt}
Bf 0 freq i=if( f==0,v(FM),f ) rpar=1
Ga nul 1 _a 0 {A1/Ro**u(Ro)}
Gb nul 2 _b 0 {A2/Ro**u(Ro)}
Gc nul 3 _c 0 {A3/Ro**u(Ro)}
IDC1 nul 1 {DC1/Ro**u(Ro)}
IDC2 nul 2 {DC2/Ro**u(Ro)}
IDC3 nul 3 {DC3/Ro**u(Ro)}
Ra _a 0 R=if(amp==0,v(am),amp)
Rb _b 0 R=if(amp==0,v(am),amp)
Rc _c 0 R=if(amp==0,v(am),amp)
Roa nul {if( Ro==0,00,1 )} {Ro**u(Ro)}
Rob nul {if( Ro==0,00,2 )} {Ro**u(Ro)}
Roc nul {if( Ro==0,00,3 )} {Ro**u(Ro)}
Rfm 0 FM 1G
Ram 0 AM 1G
Rpm 0 PM 1G
.ends 3ph_gen
********************************************************************************
*
*			3ph_SW - Three-phase switch
*
********************************************************************************
*
* [CHARACTERISTICS]
*
* - It starts {ON}, continues {OFF} then goes back {ON}.
*
*
* [NOTES]
*
* - Default ON/OFF resistances are 1mOhm/1MegOhm.
*
********************************
*
*	       1st input, phase 'A'
*	       |  1st input, phase 'B'
*	       |  |  1st input, phase 'C'
*	       |  |  |	2nd input, phase 'A'
*	       |  |  |	|  2nd input, phase 'B'
*	       |  |  |	|  |  2nd input, phase 'C'
*	       |  |  |  |  |  |	 output, phase 'A'
*	       |  |  |	|  |  |	 | output, phase 'B'
*	       |  |  |	|  |  |	 | | output, phase 'C'
*	       |  |  |	|  |  |	 | | |
.subckt 3ph_SW a1 b1 c1 a2 b2 c2 A B C
.model sw sw(Ron=1m Roff=1Meg vt=0 vh=-1m)
S1 A A1 on-off-ctl 0 SW
S2 B B1 on-off-ctl 0 SW
S3 C C1 on-off-ctl 0 SW
S4 A A2 0 on-off-ctl SW
S5 B B2 0 on-off-ctl SW
S6 C C2 0 on-off-ctl SW
I1 0 on-off-ctl pulse(-1 1 {ON} {min(ON,OFF)/1k} {min(ON,OFF)/1k} {OFF} {ON+OFF+min(ON,OFF)/500})
R4 on-off-ctl 0 1
.ends 3ph_SWz
********************************************************************************
*
*		BrdgRect, BrdgRectThy - Rectifying bridges
*
********************************************************************************
*
* [PARAMETERS]
*
* Ron	[Ohm]	= on-state resistance;
* Roff	[Ohm]	= off-state resistance;
* Vfwd	[V]	= conduction voltage drop;
* Vrev	[V]	= reverse break-down voltage;
* Rs,Cs	[Ohm,F]	= series snubber across each device;
* f	[Hz]	= working frequency, BrdgRectThy only;
* phi	[rad]	= phase displacement, BrdgRectThy only;
* ang	[rad]	= firing angle, BrdgRectThy only;
*
* - Hidden:
*
* td,tau[s]	= LTspice's specific parameters for A-devices, {tau} gives a
*		simplistic approach for dead-time control, BrdgRectThy only;
*
*
* [NOTES]
*
* - The series RC snubber can have any of the two elements null, but not both at
* the same time.
*
********************************
*
*	Controlled angle
*
********************************
*
* [SYMBOL]
*
* A,B,C		= three-phase, AC current, input pins;
* +,-		= DC output pins;
* S[1:3]	= external firing angle commands;
* EN		= external commands enable pin.
*
* - Control inputs are internally grounded with 1GOhm.
* - If 'EN' is grounded or floating, anything at pins 'S[1:3]' is ignored.
*
*
* [CHARACTERISTICS]
*
* - There is a minimal dead-time internally generated so, for external control,
* only the signal for the upper leg switches are needed at pins 'S[1:3]'.
*
* - If pin 'EN' is not used, internal firing angle is generated based on {f},
* {phi} and {ang}: {f} sets the working frequency, {phi} the displacement and
* {ang} the firing angle. This scheme is based on balanced/undistorted signals.
*
*
* [NOTES]
*
* - There is a hidden parameter, {tau}, which sets the rising/falling time for
* the final logic gates commanding the switches, which have a hysteresis of 0.4V
* giving some simple dead-time control.
*
********************************
*
*		     phase 'A' input
*		     | phase 'B' input
*		     | | phase 'C' input
*		     | | | Positive output
*		     | | | | Negative output
*		     | | | | | phase 'A' control
*		     | | | | | |    phase 'B' control
*		     | | | | | |    |	 phase 'C' control
*		     | | | | | |    |	 |    enable/_disable external control
*		     | | | | | |    |	 |    |
.subckt BrdgRectThy  A B C + - S[1] S[3] S[5] EN
.param Rs=1k Cs=1n Ron=50m Roff=100k Vfwd=1 Vrev=1k f=50  phi=0 ang=2.5m
+ dt=1u td=10n
.param tripdv=1 tripdt=1u
.model thy sw(Ron={Ron/2} Roff={Roff/2} vt=.5 vh=-0.4)
.model d d(vfwd={Vfwd} Vrev={Vrev} Ron={Ron/2} Roff={Roff/2})
S1 N001 A c1 0 thy
S4 N004 - c4 0 thy
S3 N002 B c3 0 thy
S6 N005 - c6 0 thy
S5 N003 C c5 0 thy
S2 N006 - c2 0 thy
D1 N001 + D
D4 N004 A D
D3 N002 + D
D6 N005 B D
D5 N003 + D
D2 N006 C D
Cs1 + A {Cs} Rser={Rs}
Cs4 A - {Cs} Rser={Rs}
Cs3 + B {Cs} Rser={Rs}
Cs6 B - {Cs} Rser={Rs}
Cs5 + C {Cs} Rser={Rs}
Cs2 C - {Cs} Rser={Rs}
B1 n1 0 i=if(v(EN)|v(+,A)-v(A)==0,0,if(v(+,B)-v(B)==0,-v(n5),if(v(+,C)-v(C)==0,-v(n3),sgn(sin(2*pi*f*time-ang-pi/6*inv(v(+,B)-v(B)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
B3 n3 0 i=if(v(EN)|v(+,B)-v(B)==0,0,if(v(+,A)-v(A)==0,-v(n5),if(v(+,C)-v(C)==0,-v(n1),sgn(sin(idt(2*pi*f)-ang-2*pi/3-pi/6*inv(v(+,A)-v(A)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
B5 n5 0 i=if(v(EN)|v(+,C)-v(C)==0,0,if(v(+,B)-v(B)==0,-v(n1),if(v(+,A)-v(A)==0,-v(n3),sgn(sin(idt(2*pi*f)-ang+2*pi/3-pi/6*inv(v(+,B)-v(B)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
C1 n1 0 10p Rpar=1
C3 n3 0 10p Rpar=1
C5 n5 0 10p Rpar=1
An1 0 n1 0 EN 0 1 0 0 OR td={td}
As1 0 EN 0 s[1] 0 0 4 0 AND td={td}
A14 0 1 0 4 0 c4 c1 0 OR td={td} trise={dt*2}
An3 0 n3 0 EN 0 3 0 0 OR td={td}
As3 0 EN 0 s[2] 0 0 6 0 AND td={td}
A36 0 3 0 6 0 c6 c3 0 OR td={td} trise={dt*2}
As5 0 EN 0 s[3] 0 0 2 0 AND td={td}
An5 0 n5 0 EN 0 5 0 0 OR td={td}
A52 0 5 0 2 0 c2 c5 0 OR td={td} trise={dt*2}
Ren EN 0 1G
Rs[1] s[1] 0 1G
Rs[2] s[2] 0 1G
Rs[3] s[3] 0 1G
.ends BrdgRectThy
********************************
*
*	Fixed (no) angle
*
********************************
*
*		 phase 'A' input
*		 | phase 'B' input
*		 | | phase 'C' input
*		 | | | Positive output
*		 | | | | Negative output
*		 | | | | |
*		 | | | | |
*		 | | | | |
*		 | | | | |
*		 | | | | |
.subckt BrdgRect A B C + -
.param Vfwd=0.7 Vrev=1k Ron=50m Roff=100k Rs=100k Cs=0
.model d d( Ron={Ron} Roff={Roff} Vfwd={Vfwd} Vrev={Vrev} )
D1 A + D
C1 + A {Cs} Rser={Rs}
D2 B + D
C2 + B {Cs} Rser={Rs}
D3 C + D
C3 + C {Cs} Rser={Rs}
D4 - A D
C4 A - {Cs} Rser={Rs}
D5 - B D
C5 B - {Cs} Rser={Rs}
D6 - C D
C6 C - {Cs} Rser={Rs}
.ends BrdgRect
********************************************************************************
*
*			Cable - 4-wire cable
*
********************************************************************************
*
* [GENERAL]
*
* - Inside it's a PI LC low-pass with two R at the input/output. It uses some
* approximations and many simplifications but, for not so large powers, it is a
* fairly good model.
*
*
* [PARAMETERS]
*
* phi	[m]	= wire (equivalent) diameter;
* f	[Hz]	= nominal frequency;
* len	[m]	= length of cable;
* CuAl=<0,1>	= whether copper <0> or aluminium <1> wire is used;
* T	[C]	= working temperature;
* Space	[m]	= distance between the exterior of wires' insulations;
* Dins	[m]	= insulation diameter;
* TriPlan=<0,1>	= whether the wires are disposed in planar <1> or triangle
* 		formation <0>.
* - Hidden:
*
* ratio=<0:0.5>	= determines the distribution of the series resistance between
*		the ending Rs and PI's middle L: <0.5> (default) means the
*		resistances at the ends get 1/2 of the value, each, while the
*		inductance has none; <0> means L gets all the resistance while
*		the ending resistors none.
*
*
* [CHARACTERISTICS]
*
* - If not all the wires are used, ground only one of the inputs/outputs of each
* unused ones. e.g.: if the null is unused, ground one of the two empty pins and
* leave the other floating.
*
* - ratio=0.5 may prove to be faster in some .TRAN applications, but it's there
* for experimenting. 
*
********************************
.subckt Cable 11 21 31 41 10 20 30 40
.param phi=2m f=50 len=20 CuAl=2 T=27 Space=5m Dins=5m TriPlan=1 ratio=0.5
+ RparC=10*XC RparL=10*XL
.param Rdc=rho/Aw*(1+alpha*(T-20))
.param rhoCu=17.241n  rhoAl=28.264n  rho=if( CuAl==1,rhoCu,rhoAl )
.param alphaCu=3.93m  alphaAl=4.03m  alpha=if( CuAl==1,alphaCu,alphaAl )
.param Aw=pi*phi**2/4
.param Rac=Rdc*(1+ys+yp2)  Rac2=Rdc*(1+ys+yp)
.param xs=0.8u*pi*f/Rdc  ys=xs**2/(192+0.8*xs**2)
.param yp=xp**2/(192+0.8*xp**2)*(phi/_Space)**2*2.9
.param yp2=xp**2/(192+0.8*xp**2)*(phi/_Space)**2*(0.312*(phi/_Space)**2+1.18*(192+0.8*xp**2)/xp**2+0.27)
.param xp=0.8u*pi*f/Rdc
.param _Space=1.26**TriPlan*(Space+phi+Dins/2)
.param XL=2*pi*f*L  R=Rac*len  Rn=Rac2*len  C=8/(18g*log(_Dins/phi))*len
.param L=(0.05+0.2*log(2*_Space/phi))*len*1u
.param _Dins=if( Dins<=phi,phi,Dins ) XC=1/2/pi/f/C
Ra1 {u(ratio)*90+11} 11 {R*ratio**u(ratio)}
Rb1 {u(ratio)*180+21} 21 {R*ratio**u(ratio)}
Rc1 {u(ratio)*270+31} 31 {R*ratio**u(ratio)}
Rn1 41 401 {Rn*ratio**u(ratio)}
Ra2 {u(ratio)*92+10} 10 {R*ratio**u(ratio)}
Rb2 {u(ratio)*182+20} 20 {R*ratio**u(ratio)}
Rc2 {u(ratio)*272+30} 30 {Rn*ratio**u(ratio)}
Rn2 40 402 {Rn*ratio**u(ratio)}
Ca1 {u(ratio)*90+11} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Ca2 {u(ratio)*92+10} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cb1 {u(ratio)*180+21} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cb2 {u(ratio)*182+20} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cc1 {u(ratio)*270+31} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cc2 {u(ratio)*272+30} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
La {u(ratio)*90+11} {u(ratio)*92+10} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Lb {u(ratio)*180+21} {u(ratio)*182+20} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Lc {u(ratio)*270+31} {u(ratio)*272+30} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Ln 401 402 {L} Rser={Rn*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
.ends Cable
********************************************************************************
*
*			Disturb - Disturbance signal
*
********************************************************************************
*
* [GENERAL]
*
* - It's a Gaussian bell modulated sine with skew factor given by a tanh(). For
* a better understanding the parameters, here's a minor helping graph (use fixed
* font, tab=8):
*
*	^	  sigma
*	|	<------>*	.........
*	|	.    *	.  *		^
*	|	.   *	.   *		|
*	|	.  *	.    *		| B
*	|	.*	.      *	|
*	|* * * *	.	 * * * *V........
*	|	delay	.			^
*	|<------------->.			| A
*	|					V
*	+------------------------------------------->
*
*
* [PARAMETERS]
*
* A		= amplitude outside the "bell";
* B		= amplitude of the bell itself;
* delay	[s]	= delay at which the peak of the bell occurs;
* sigma		= the Gaussian distribution factor;
* xp=<0:inf>	= the exponent of the exponent multiplier: exp[-(t/x)^(2*xp)];
* skew=<0:inf>	= the skew factor;
* f	[Hz]	= frequency of the modulated sine;
* phi	[rad]	= phase of the modulated sine;
* sq		= time's exponent for the sine;
*
*
* [CHARACTERISTICS]
*
* - If skew=0, the bell's height is given by {B}m else it is half its height,
* growing with {skew} but never reaching {B}. Also, skewing will be done around
* the delay point.
*
* - {sigma} is divided by 3 to approximate the bell as having two halves of
* {sigma}'s width around the delay point. E.g.: .TRAN 1, delay=0.5 and sigma=0.1
* => the bell starts at ~0.4s, rises to its maximum at 0.5s and ends at ~0.6s.
*
* - {sigma} is also proportional to {delay}, e.g. .TRAN 1m, delay=0.5m => if a
* +/-0.1ms bell width is wanted, sigma=0.1m.
*
* - {xp} sets a sharper bell shape with inflexion points around delay+/-sigma.
*
* - {sq} is a crude way of squaring/square rooting the time quantity on the sine
* function in order to give a time sweep without too much speed penalty.
* 
*
* [NOTES]
*
* - {skew} can take very large values for a visible effect to take place.
*
* - If only the bell shape is needed, set phi=pi/2 and sq=0 (skew=0).
*
* - Output resistance is {A}.
*
********************************
.subckt disturb out
.param  A=1 B=0.1 delay=0.5 sigma=0.1 xp=1 skew=0 f=10 phi=0 sq=1
B1 0 out i=1+B/A*exp( -4.5*((time-delay)/sigma)**(2*xp) )*sin(2*pi*f*time**sq+phi)*(tanh(time*skew/delay-skew)**u(skew)/2+.5) Rpar={A}
.ends disturb
********************************************************************************
*
*		Isense, Vsense - Current/voltage sensors
*
********************************************************************************
*
* [PARAMETERS]
*
* G [linear]	= gain/attenuation.
*
*
* [CHARACTERISTICS]
*
* - The input for the voltage sensor is floating.
*
* - The series resistance for the current sensor is zero.
*
* - Output resistance is 1 Ohm for both.
*
************************
*
*	Current
*
************************
.subckt Isense + - out+ out-
F1 out- out+ v1 {G}
R2 out- out+ 1
V1 + - 0
.ends Isense
************************
*
*	Voltage
*
************************
.subckt Vsense + - out+ out-
R1 out- out+ 1
G1 out- out+ + - {G}
.ends Vsense
********************************************************************************
*
*			RLC - Universal RLC load
*
********************************************************************************
*
* [PARAMETERS]
*
* V	[V]	= line-to-line RMS voltage;
* f	[Hz]	= working frequency;
* NUL=<0,1>	= specifies whether null is present <1> or not <0>, Y-connection
*		only;
* DY=<0,1>	= specifies whether the configuration is a delta-connection <0>,
*		or a wye-connection <1>;
* SP=<0,1>	= specifies whether it's series <0>, or parallel <1> RLC branch;
* P	[W]	= active power;
* QL	[VAr]	= inductive reactive power;
* QC	[VAr]	= capacitive reactive power;
* Rd	[Ohm]	= damping resistor;
*
*
* [CHARACTERISTICS]
*
* - "Rd" is only active when a directly driven L or C is about, for example the
* parallel RLC case, if zero it defaults to 1mOhm.
* 
* [NOTES]
*
* - It is possible to have any combination for the three powers, including null
* ones.
*
********************************
*
*	    phase 'A' input
*	    | phase 'B' input

*	    | |	phase 'C' input
*	    | |	| null
*	    | |	| |
.subckt RLC 1 2 3 4
.param  V=400  f=50  NUL=1  DY=1  SP=0  P=10k  QL=5k  QC=2k  Rd=1
.param   w=2*pi*f  N=if( DY==0,0,NUL )
+ m=if( DY==0,sqrt(3),1)  U=if( N, V/sqrt(3), V )
+ S=sqrt( P**2+(QL-QC)**2 )/m  I=S/U
+ Pd=Rdamp*I**2  Ud=Rdamp*I
+ Z=if( SP, U**2/S, S/I**2 )
+ R=if( P==0, 1, if( SP, U**2*m**2/P, P/I**2 ) )*3**N
+ XL=if( SP, U**2*m**2/QL, QL/I**2 )*3**N
+ XC=if( SP, U**2*m**2/QC, QC/I**2 )*3**N
+ L=if( QL,  XL/w, 1 )  C=if( QC, 1/w/XC, 1 )
.param NC11=if( ( QC>0 & DY & SP==0 ) | ( QL==0 & QC>0 & DY & SP ), 1,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 2, 0 ) )
.param NC10=if( ( QC>0 & DY & SP==0 & N==0 ) | ( QL==0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( QC>0 & DY & SP==0 & N ) | ( QL==0 & QC>0 & DY & SP & N ), 4,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 3, 0 ) ) )
.param NC22=if( ( QC>0 & SP==0 ) | ( QL==0 & QC>0 & SP ), 2, 0 )
.param NC20=if( ( QC>0 & DY & SP==0 & N==0 ) | ( QL==0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( QC>0 & DY & SP==0 & N ) | ( QL==0 & QC>0 & DY & SP & N ), 4,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 1, 0 ) ) )
.param NC33=if( ( QC>0 & SP==0 ) | ( QL==0 & QC>0 & SP ), 3, 0 )
.param NC30=NC20
.param NL11=if( ( QL>0 & QC>0 & DY & SP ) | ( QL>0 & QC==0 & DY ), 1,
+ if( ( QL>0 & QC>0 & DY==0 & SP ) | ( QL>0 & QC==0 & DY==0 ), 2, 0 ) )
.param NL10=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 10,
+ if( QL>0 & QC==0 & DY==0, 3, 0 ) ) ) )
.param NL22=if( ( QL>0 & QC>0 & SP ) | ( QL>0 & QC==0 ), 2, 0 )
.param NL20=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 20,
+ if( QL>0 & QC==0 & DY==0, 1, 0 ) ) ) )
.param NL33=if( ( QL>0 & QC>0 & SP ) | ( QL>0 & QC==0 ), 3, 0 )
.param NL30=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 30,
+ if( QL>0 & QC==0 & DY==0, 1, 0 ) ) ) )
.param NR11=if( P>0 & QL==0 & QC==0 & DY, 1,
+ if( P>0 & QL==0 & QC==0 & DY==0, 2,
+ if( QL>0 & QC>0 & SP, 10, 0 ) ) )
.param NR10=if( ( P>0 & QL==0 & QC==0 & DY & N==0 ) | ( QL>0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( P>0 & QL==0 & QC==0 & DY & N ) | ( QL>0 & QC>0 & DY & SP & N ), 4,
+ if( ( P>0 & QL==0 & QC==0 & DY==0 ) | ( QL>0 & QC>0 & DY==0 & SP ), 3, 0 ) ) )
.param NR22=if( P>0 & QL==0 & QC==0, 2,
+ if( QL>0 & QC>0 & SP, 20, 0 ) )
.param NR20=if( ( P>0 & QL==0 & QC==0 & DY & N==0 ) | ( QL>0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( P>0 & QL==0 & QC==0 & DY & N ) | ( QL>0 & QC>0 & DY & SP & N ), 4,
+ if( ( P>0 & QL==0 & QC==0 & DY==0 ) | ( QL>0 & QC>0 & DY==0 & SP ), 1, 0 ) ) )
.param NR33=if( P>0 & QL==0 & QC==0, 3,
+ if( QL>0 & QC>0 & SP, 30, 0 ) )
.param NR30=NR20
.param Cs=C
.param Rs=if( P>0 & QC>0 & SP==0, R, Rdamp )
.param Ls=if( QL>0 & QC>0 & SP==0, L, 0 )
.param Rsp=if( P>0 & QL==0 & QC>0 & SP, R, 0 )
.param Lp=L
.param Rp=if( P>0 & QL>0 & SP, R, 0 )
.param Cp=if( QL>0 & QC>0 & SP, C, 0 )
.param Rps=if( P>0 & QL>0 & QC==0 & SP==0, R,
+ if( QL>0 & QC>0 & SP, 0, Rdamp ) )
.param Rdamp=if( ( P==0 & ( QL>0 | QC>0 ) & SP==0 ) |
+   ( ( QL>0 | QC>0 ) & SP ), Rd, 1m )
.param Rx= if( QL>0 & QC>0 & SP, Rdamp, R )
Ra {NR11} {NR10} {Rx}
Rb {NR22} {NR20} {Rx}
Rc {NR33} {NR30} {Rx}
La {NL11} {NL10} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Lb {NL22} {NL20} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Lc {NL33} {NL30} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Ca {NC11} {NC10} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
Cb {NC22} {NC20} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
Cc {NC33} {NC30} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
.ends RLC
********************************************************************************
*
*				wt - Angle generator
*
********************************************************************************
*
* [GENERAL]
*
* - A more practical and space-efficient approach for grid PLL's wt.
*
*
* [PARAMETERS]
*
* f	[Hz]	= frequency;
* phi	[rad]	= phase;
*
* - Hidden:
*
* tripdt[s]	= LTspice's specific, improves the fast transitions if needed.
*
********************************
.subckt wt out
.param f=50 phi=0 tripdt=1u
B1 0 out Rpar=1 i=idtmod( 2*pi*f, phi, 2*pi ) tripdv=5 tripdt={tripdt}
.ends wt
********************************************************************************
*
*				TL494
*
********************************************************************************
*
* [GENERAL]
*
* - Heavily idealized behavioural model. During its evolution, some adjustments
* have been done thanks to adurandza (push-pull  fix) and pogankin (UV lockout,
* output capacitors for improvement of switching behaviour).
*
*
* [CHARACTERISTICS]
*
* - The oscillator gives a ~0.1% accurate frequency, by the book, but RT should
* be above 10k for best results.
*
* - The output stage has a current limit of 200mA.
*
*
* [NOTES]
*
* - The pin order, as it appears in the .subckt, is as in the datasheet.
*
********************************
*
*		1    2	 3   4	5  6	7    8  9  10 11 12  13	14  15	 16
*		|    |	 |   |	|  |	|    |  |  |  |	 |   |	|   |	 |
.subckt TL494  1IN+ 1IN- FB DTC CT RT GROUND C1 E1 E2 C2 VCC OC REF 2IN- 2IN+
.model CTSW sw(Ron=1m)
.model drv sw(Ron=0.1 Roff=1e6 vt=2.5 vh=0 vser=1.1 Ilimit=0.2)
.model dlim d vfwd=1m vrev=5
.model dea d vfwd=0.7
Aor1 _Ref _DT _FB OVP RTN RTN OR RTN OR vhigh=4.8 vlow=0.2 td=50n
Aor2 RTN AND1 RTN OR RTN DRV1 RTN RTN OR vhigh=4.8 vlow=0.2 td=50n
Aor3 RTN AND2 RTN OR RTN DRV2 RTN RTN OR vhigh=4.8 vlow=0.2 td=50n
Aand1 RTN OC RTN Q RTN RTN AND1 RTN AND vhigh=4.8 vlow=0.2 td=50n
Aand2 RTN _Q RTN OC RTN RTN AND2 RTN AND vhigh=4.8 vlow=0.2 td=50n
A_DFF _Q RTN OR RTN RTN _Q Q RTN DFLOP vhigh=4.8 vlow=0.2 td=50n
I2 FB RTN 0.7m
DEA1 EA1_out FB DEA
GEA1 RTN EA1_out 1IN+ 1IN- 55k
CEA1 EA1_out RTN 11m Rpar=1
GEA2 RTN EA2_out 2IN+ 2IN- 55k
CEA2 EA2_out RTN 11m Rpar=1
S_CT RTN CT RTN res CTSW
A_CT CT RTN RTN RTN RTN res RTN RTN SCHMITT vt=1.5 vh=1.499 vhigh=1 vlow=-1 td=10n
E_RT RT RTN Ref RTN 0.72
SQ1 E1 C1 DRV1 RTN drv
SQ2 E2 C2 DRV2 RTN drv
Dlim1 RTN FB Dlim
DEA2 EA2_out FB DEA
CQ1 C1 E1 10p
CQ2 C2 E2 10p
REA2 2IN+ 2IN- 12.5Meg
REA1 1IN+ 1IN- 12.5Meg
Rdraw Vcc RTN 2667
F_CT RTN CT E_RT -1
A_CT_DTC CT DTC RTN RTN RTN _DT RTN RTN SCHMITT td=10n vhigh=4.8 vlow=0.2 vt=0.12 vh=0
A_CT_FB CT FB RTN RTN RTN _FB RTN RTN SCHMITT td=10n vhigh=4.8 vlow=0.2 vt=-0.7 vh=0
A_OVP VCC RTN RTN RTN RTN RTN OVP RTN SCHMITT td=10n vhigh=4.8 vlow=0.2 vt=40 vh=0
Aref Vcc RTN RTN RTN RTN _Ref Ref RTN SCHMITT vt=5 vh=0 vhigh=5 vlow=0 td=10n
.ends TL494
********************************************************************************
*
*				WattMeter - Wattmeter
*
********************************************************************************
*
* [PARAMETERS]
*
* att		= attenuation to avoid slow-downs for calculations due to large
*		processed signals;
* f	[Hz]	= working frequency;
*
* - Hidden:
*
* tripdv,tripdt,tripdt2	= LTspice's specific parameters for A-devices;
* off	[V]	= offset tweak for the clock generators;
*
*
* [CHARACTERISTICS]
*
* - The voltage sensing has floating input and the current sensing is a zero-
* resistance series voltage source.
*
* - The output resistances for pins 'V' and 'I' is Ro=att/2, for 'S' and 'P' is
* Ro=att^2/2, while for 'Q' and 'PF' is Ro=att.
* 
* [NOTES]
*
* - The hidden parameters shouldn't need tinkering but, if needed:
*	- {tripdv} and {tripdt} control the timestep for the behavioural sources
*	calculating the powers (default <100V/1us>), these can be tinkered with;
*	- {tripdt2} controls the timestep of the clock and resetting pulses and
*	it should be tighter than {tripdt} because the resetting pulses are set
*	to be very narrow for a minimal impact (default 10n);
*	- {off} shifts the filtered voltage input by a minimal amount in order
*	to generate delayed resetting pulses.
*
********************************
*
*		  current sensing input
*		  |  voltage sensing positive input
*		  |  |	voltage sensing negative input
*		  |  |	|  current sensing output
*		  |  |	|  |  apparent power output
*		  |  |	|  |  |	active power
*		  |  |	|  |  |	| reactive power
*		  |  |	|  |  |	| | power factor
*		  |  |	|  |  |	| | |  RMS voltage
*		  |  |	|  |  |	| | |  | RMS current
*		  |  |	|  |  |	| | |  | |
.subckt WattMeter I+ V+ V- I- S P Q PF V I
.param att=100  f=50  tripdt=1u  tripdv=100  off=1m  tripdt2=10n
Vamper I+ I- 0
Gvolt 0 filt V+ V- {1/att}
Cf filt 0 {1/4/pi/f} Lser=0 Rpar=0 Cpar=0 RLshunt=0 ic=0 Rpar=1
Bper 0 per i=idt( 0, idt( 1,0,v(res) ), v(clk) ) tripdt={tripdt} tripdv={tripdv} rpar=1
B_per 0 _per i=idt( 0, idt( 1,0,v(_res) ), v(_clk) ) tripdt={tripdt} tripdv={tripdv} rpar=1
Bclk 0 clk i=u( ddt( sgn(v(filt)) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
B_clk 0 _clk i=u( ddt( sgn(-v(filt)) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
Bres 0 res i=u( ddt( sgn(v(filt)-off) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
B_res 0 _res i=u( ddt( sgn(-v(filt)-off) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
BV 0 V i=idt( 0, idt( i(Gvolt)**2,0,v(res) ) / v(per), v(clk) )**0.5 + idt( 0, idt( i(Gvolt)**2,0,v(_res) ) / v(_per), v(_clk) )**0.5 tripdt={tripdt} tripdv={tripdv} rpar={att/2}
BI 0 I i=idt( 0, idt( i(Vamper)**2/att**2,0,v(res) ) / v(per), v(clk) )**0.5 + idt( 0, idt( i(Vamper)**2/att**2,0,v(_res) ) / v(_per), v(_clk) )**0.5 tripdt={tripdt} tripdv={tripdv} rpar={att/2}
BS 0 S i=V(V)*V(I)/att**2 tripdt={tripdt} tripdv={tripdv} rpar={att**2}
BP 0 P i=idt( 0, idt( I(Gvolt)*I(Vamper)/att,0,v(res) ) / v(per), v(clk) ) + idt( 0, idt( I(Gvolt)*I(Vamper)/att,0,v(_res) ) / v(_per), v(_clk) ) tripdt={tripdt} tripdv={tripdv} rpar={att**2/2}
BQ 0 Q i=sqrt(V(S)**2-V(P)**2)/att tripdt={tripdt} tripdv={tripdv} rpar={att}
BPF 0 PF i=limit( 0, V(P)/V(S)/att, 1/att ) tripdt={tripdt} tripdv={tripdv} rpar={att}
.ends WattMeter
********************************************************************************
*
* [UPDATES]
*
* 2013.01.19	- Corrected 3ph_br_cm and SVHCC.
*		- Overall modifications and improvements.
* 2013.01.26	- Modified 3ph_gen's phase control: {phi[1:3]} control only the
*		fundamental and {phi} only the harmonics, while V(PM) is added
*		to the overall result.
* 2013.01.27	- Added a minor hysteresis to 3ph_SW to avoid random glitches.
*		- Minor modifications/corrections.
* 2013.02.04	- Modified the Cable model, it should now behave better under
*		distorted conditions and be slightly faster.
*
********************************************************************************
